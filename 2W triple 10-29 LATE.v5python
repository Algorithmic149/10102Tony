{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_1 = Controller(PRIMARY)\nL_motor_a = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nL_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nL = MotorGroup(L_motor_a, L_motor_b)\nR_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nR_motor_b = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\nR = MotorGroup(R_motor_a, R_motor_b)\nrollerxintake = Motor(Ports.PORT10, GearSetting.RATIO_36_1, True)\nexp = Motor(Ports.PORT7, GearSetting.RATIO_18_1, False)\ncatapult_motor_a = Motor(Ports.PORT6, GearSetting.RATIO_36_1, False)\ncatapult_motor_b = Motor(Ports.PORT9, GearSetting.RATIO_36_1, True)\ncatapult = MotorGroup(catapult_motor_a, catapult_motor_b)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\nglobal x\nx = 1\ndef forward(dis, speed):\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    motordegrees = dis*360/17.016960207\n    integral = 0\n    Lerror = motordegrees - L.position(DEGREES) #Lerror\n    Rerror = motordegrees - R.position(DEGREES)\n    while (Lerror+Rerror)/2>0:\n        Lerror = motordegrees - L.position(DEGREES) #Lerror\n        Rerror = motordegrees - R.position(DEGREES)#Rerror\n        integral = integral + (Lerror + Rerror)/2 #increase integral\n       \n        Lspeed = speed*(Lerror/1000 + integral/60000) #speed\n        Rspeed = speed*(Rerror/1000 + integral/60000) #speed\n        L.set_velocity(Lspeed, PERCENT)\n        R.set_velocity(Rspeed, PERCENT)\n        controller_1.screen.print((Lerror+Rerror)/2)\n        controller_1.screen.next_row()\n    \n        \n     \n        controller_1.screen.print(Lerror/1000+integral/60000)\n        wait(10, MSEC)\n        controller_1.screen.clear_screen()\n        controller_1.screen.set_cursor(1, 1)\n    L.stop()\n    R.stop()\ndef backward(dis, speed):\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(REVERSE)\n    R.spin(REVERSE)\n    motordegrees = dis*-360/17.016960207\n    integral = 0\n    Lerror = motordegrees - L.position(DEGREES) #Lerror\n    Rerror = motordegrees - R.position(DEGREES)\n    #lerror and rerror are NEGATIVE\n    while (Lerror+Rerror)/2<0:\n        Lerror = motordegrees - L.position(DEGREES) #Lerror\n        Rerror = motordegrees - R.position(DEGREES)#Rerror\n        integral = integral + (Lerror + Rerror)/2 #increase integral\n       \n        Lspeed = speed*(Lerror/1000 + integral/60000) #speed\n        Rspeed = speed*(Rerror/1000 + integral/60000) #speed\n        L.set_velocity(Lspeed, PERCENT)\n        R.set_velocity(Rspeed, PERCENT)\n        #controller_1.screen.print((Lerror+Rerror)/2)\n        #controller_1.screen.next_row()\n    \n        \n     \n        controller_1.screen.print(Lerror/1000+integral/24000)\n        wait(10, MSEC)\n        controller_1.screen.clear_screen()\n        controller_1.screen.set_cursor(1, 1)\n    L.stop()\n    R.stop()\ndef turnright(angles):\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(FORWARD)\n    R.spin(REVERSE)\n    motordegrees = (angles-21)*2.72307692419\n    integral = 0\n    Lerror = motordegrees - L.position(DEGREES) #Lerror\n    Rerror = motordegrees*-1 - R.position(DEGREES)\n    #RERROR IS NEGATIVE WHILE LERROR IS POSITIVE\n    \n    while (Lerror-Rerror)/2>0:\n        Lerror = motordegrees - L.position(DEGREES) #Lerror\n        Rerror = motordegrees*-1 - R.position(DEGREES)#Rerror\n        integral = integral + (Lerror - Rerror)/2 #increase integral\n       \n        Lspeed = 90*(Lerror/1000 + integral/60000) #speed\n        Rspeed = 90*(Rerror/-1000 + integral/60000) #speed\n        L.set_velocity(Lspeed, PERCENT)\n        R.set_velocity(Rspeed*-1, PERCENT)\n        controller_1.screen.print(Rerror)\n        controller_1.screen.next_row()\n    \n        \n     \n        controller_1.screen.print(Rerror/-1000+integral/60000)\n        wait(10, MSEC)\n        controller_1.screen.clear_screen()\n        controller_1.screen.set_cursor(1, 1)\n    L.stop()\n    R.stop()\ndef turnleft(angles):\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(REVERSE)\n    R.spin(FORWARD)\n    motordegrees = (angles-21)*2.72307692419\n    integral = 0\n    Rerror = motordegrees - R.position(DEGREES) #Lerror\n    Lerror = motordegrees*-1 - L.position(DEGREES)\n    #LERROR IS NEGATIVE WHILE RERROR IS POSITIVE\n    \n    while (Rerror-Lerror)/2>0:\n        Rerror = motordegrees - R.position(DEGREES) #Lerror\n        Lerror = motordegrees*-1 - L.position(DEGREES)#Rerror\n        integral = integral + (Rerror - Lerror)/2 #increase integral\n       \n        Rspeed = 90*(Rerror/1000 + integral/60000) #speed\n        Lspeed = 90*(Lerror/-1000 + integral/60000) #speed\n        R.set_velocity(Rspeed, PERCENT)\n        L.set_velocity(Lspeed*-1, PERCENT)\n        controller_1.screen.print(Lerror)\n        controller_1.screen.next_row()\n    \n        \n     \n        controller_1.screen.print(Lerror/-1000+integral/60000)\n        wait(10, MSEC)\n        controller_1.screen.clear_screen()\n        controller_1.screen.set_cursor(1, 1)\n    L.stop()\n    R.stop()\ndef onauton_autonomous_0():\n    jason = 69420\n    \n    \n    forward(26, 90)\n    turnright(97)\n    L.set_stopping(HOLD)\n    R.set_stopping(HOLD)\n    L.set_velocity(40, PERCENT)\n    R.set_velocity(40, PERCENT)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    wait(1, SECONDS)\n    L.stop()\n    R.stop()\n    wait(0.4, SECONDS)\n    rollerxintake.spin_for(REVERSE, 100, DEGREES, wait=True)\n   \n    backward(8, 150)\n    turnleft(95)\n    backward(10, 100)\n    catapult.spin_for(FORWARD, 1800, DEGREES, wait = True)\ndef when_started1():\n    catapult.set_stopping(BRAKE)\n    rollerxintake.set_stopping(BRAKE)\n    exp.stop()\n    jason = 5\n    catapult.set_velocity(100, PERCENT)\n    rollerxintake.set_velocity(100, PERCENT)\n    x = 1\n\ndef ondriver_drivercontrol_0():\n    global x\n    L.set_stopping(COAST)\n    R.set_stopping(COAST)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    while True:\n       \n        if x == 1:\n            L.set_velocity(controller_1.axis3.position(), PERCENT)\n            R.set_velocity(controller_1.axis2.position(), PERCENT)\n        else:\n\n            L.set_velocity(-controller_1.axis2.position(), PERCENT)\n            R.set_velocity(-controller_1.axis3.position(), PERCENT)\n        wait(10, MSEC)\ndef onevent_controller_1buttonUp_pressed_0():\n    rollerxintake.spin(FORWARD)\ndef onevent_controller_1buttonRight_pressed_0():\n    rollerxintake.stop()\ndef onevent_controller_1buttonDown_pressed_0():\n    rollerxintake.spin(REVERSE)\ndef onevent_controller_1buttonL1_pressed_0():\n    catapult.spin_for(FORWARD, 1800, DEGREES, wait=False)\ndef onevent_controller_1buttonL2_pressed_0():\n    catapult.spin(FORWARD)\ndef onevent_controller_1buttonL2_released_0():\n    catapult.stop()\ndef onevent_controller_1buttonX_pressed_0():\n    global x\n    x = x*-1\ndef onevent_controller_1buttonR1_pressed_0():\n    exp.spin(FORWARD)\n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    auton_task_0 = Thread( onauton_autonomous_0 )\n    # wait for the driver control period to end\n    while( competition.is_autonomous() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the autonomous control tasks\n    auton_task_0.stop()\n\ndef vexcode_driver_function():\n    # Start the driver control tasks\n    driver_control_task_0 = Thread( ondriver_drivercontrol_0 )\n\n    # wait for the driver control period to end\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the driver control tasks\n    driver_control_task_0.stop()\n\n\n# register the competition functions\ncompetition = Competition( vexcode_driver_function, vexcode_auton_function )\n# system event handlers\ncontroller_1.buttonL1.pressed(onevent_controller_1buttonL1_pressed_0)\ncontroller_1.buttonUp.pressed(onevent_controller_1buttonUp_pressed_0)\ncontroller_1.buttonRight.pressed(onevent_controller_1buttonRight_pressed_0)\ncontroller_1.buttonL2.pressed(onevent_controller_1buttonL2_pressed_0)\ncontroller_1.buttonDown.pressed(onevent_controller_1buttonDown_pressed_0)\ncontroller_1.buttonX.pressed(onevent_controller_1buttonX_pressed_0)\ncontroller_1.buttonL2.released(onevent_controller_1buttonL2_released_0)\ncontroller_1.buttonR1.pressed(onevent_controller_1buttonR1_pressed_0)\nwait(15, MSEC)\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[4,2],"name":"L","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"true","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[1,3],"name":"R","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[10],"name":"rollerxintake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[7],"name":"exp","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[6,9],"name":"catapult","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio36_1","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22}],"slot":1,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}