{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode V5 Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n#ACTUAL CONFIG --------------------------------------------\nL_motor_a = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\nL_motor_b = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)\nL_stack = Motor(Ports.PORT13, GearSetting.RATIO_6_1, True)\nL = MotorGroup(L_motor_a, L_motor_b, L_stack)\n\n\nR_motor_a = Motor(Ports.PORT18, GearSetting.RATIO_6_1, False)\nR_motor_b = Motor(Ports.PORT19, GearSetting.RATIO_6_1, False)\nR_stack = Motor(Ports.PORT20, GearSetting.RATIO_6_1, False)\nR = MotorGroup(R_motor_a, R_motor_b, R_stack)\ncontroller_1 = Controller(PRIMARY)\nRoll = Motor(Ports.PORT15, GearSetting.RATIO_36_1, True)\nFlywheel = Motor(Ports.PORT14, GearSetting.RATIO_36_1, False)\nexpansion = DigitalOut(brain.three_wire_port.b)\npp = DigitalOut(brain.three_wire_port.h)\n#ACTUAL CONFIG ---------------------------------------------\n#MOVEMENT FUNCTIONS ----------------------------------------\n#==================\n#FORWARD\n#==================\ndef forward(dis, sped):\n    degrees = 58.7649020645*dis\n    Kp = 0.085\n    Kd = 0.009\n    preverror = degrees\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    error = degrees\n    while error > 20:\n        motorposition = (L.position(DEGREES)+R.position(DEGREES))/2\n        error = degrees - motorposition\n        derivative = error - preverror\n        preverror = error\n        L.set_velocity(max((error*Kp + derivative*Kd)*sped, 10), PERCENT)\n        R.set_velocity(max((error*Kp + derivative*Kd)*sped, 10), PERCENT)\n        \n    \n        wait(100, MSEC)\n        \n  \n \n    controller_1.screen.print(\"DONE\")\n    L.stop()\n    R.stop()\n#==================\n#BACKWARD\n#==================\ndef backward(dis):\n    degrees = -58.7649020645*dis\n    Kp = 0.085\n    Kd = 0.009\n    preverror = degrees\n    error = degrees\n    derivative = 0\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    \n    while error < -20:\n        motorposition = (L.position(DEGREES)+R.position(DEGREES))/2\n        error = degrees - motorposition\n        derivative = error - preverror\n        preverror = error\n        L.set_velocity(error*Kp + derivative*Kd, PERCENT)\n        R.set_velocity(error*Kp + derivative*Kd, PERCENT)\n    \n        wait(100, MSEC)\n      \n    L.stop()\n    R.stop()\n#==================\n#TURNLEFT\n#==================\ndef turnleft(deg):\n    degrees = 58.7649020645*0.09*deg\n    Kp = 0.05\n    Kd = 0.005\n    preverror = degrees\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    error = degrees\n    while error > 0:\n        motorposition = (L.position(DEGREES)*-1+R.position(DEGREES))/2\n        error = degrees - motorposition\n        derivative = error - preverror\n        preverror = error\n        if error*Kp + derivative*Kd > 10:\n            L.set_velocity(error*Kp*-1 + derivative*Kd*-1, PERCENT)\n            R.set_velocity(error*Kp + derivative*Kd, PERCENT)\n        else:\n            L.set_velocity(-10, PERCENT)\n            R.set_velocity(10, PERCENT)\n        wait(100, MSEC)\n    L.stop()\n    R.stop()\n\n#==================\n#TURNRIGHT\n#==================\ndef turnright(deg):\n    degrees = 58.7649020645*0.109*deg\n    Kp = 0.05\n    Kd = 0.005\n    preverror = degrees\n    L.set_position(0, DEGREES)\n    R.set_position(0, DEGREES)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    error = degrees\n    while error > 0:\n        motorposition = (L.position(DEGREES)+R.position(DEGREES)*-1)/2\n        error = degrees - motorposition\n        derivative = error - preverror\n        preverror = error\n       \n        if error*Kp + derivative*Kd > 10:\n            L.set_velocity(error*Kp + derivative*Kd, PERCENT)\n            R.set_velocity(error*Kp*-1 + derivative*Kd*-1, PERCENT)\n        else:\n            L.set_velocity(10, PERCENT)\n            R.set_velocity(-10, PERCENT)\n        wait(100, MSEC)\n    L.stop()\n    R.stop()\ndef when_started1():\n    global sussy\n    sussy = 'dabby'\n    L.set_stopping(COAST)\n    R.set_stopping(COAST)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    Flywheel.set_velocity(88, PERCENT)\n    Flywheel.set_stopping(COAST)\n    Roll.set_velocity(80, PERCENT)\n    Roll.set_stopping(COAST)\ndef onauton_autonomous_0():\n    x = 'hi'\n    global deez\n    deez = 0\n    L.set_stopping(HOLD)\n    R.set_stopping(HOLD)\n    L.set_velocity(15, PERCENT)\n    R.set_velocity(15, PERCENT)\n    L.set_max_torque(20, PERCENT)\n    R.set_max_torque(20, PERCENT)\n    Flywheel.set_velocity(100, RPM)\n    Flywheel.spin(FORWARD)\n    #L.spin(FORWARD)\n    #R.spin(FORWARD)\n    L.set_velocity(15, PERCENT)\n    R.set_velocity(15, PERCENT)\n    L.set_max_torque(20, PERCENT)\n    R.set_max_torque(20, PERCENT)\n\n \n\n    Roll.spin_for(REVERSE, 150, DEGREES, True)\n\n\n    L.set_max_torque(100, PERCENT)\n    R.set_max_torque(100, PERCENT)\n    L.stop()\n    R.stop()\n    wait(2, SECONDS)\n    pp.set(True)\n    wait(0.2, SECONDS)\n    pp.set(False)\n    wait(2, SECONDS)\n    pp.set(True)\n    wait(0.2, SECONDS)\n    pp.set(False)\n    #backward(3)\n    #turnleft(154)\n    #Roll.spin(FORWARD)\n    #forward(35, 0.8)\n    #wait(0.5, SECONDS)\n    \n    #forward(24, 0.3)\n    \n    \n    turnright(88)\n    backward(10)\n    pp.set(True)\n    wait(0.2, SECONDS)\n    pp.set(False)\n    wait(2, SECONDS)\n    pp.set(True)\n    wait(0.2, SECONDS)\n    pp.set(False)\n    wait(2, SECONDS)\n    pp.set(True)\n    wait(0.2, SECONDS)\n    pp.set(False)\n    \n\n\n \n\ndef ondriver_drivercontrol_0():\n    global sussy\n    sussy = 'bus'\n    global x\n    expansion.set(False)\n    global deez\n    deez = 0\n    L.set_stopping(COAST)\n    R.set_stopping(COAST)\n    L.spin(FORWARD)\n    R.spin(FORWARD)\n    L.set_max_torque(100, PERCENT)\n    R.set_max_torque(100, PERCENT)\n    Flywheel.set_velocity(75, PERCENT)\n    Flywheel.set_stopping(COAST)\n    Roll.set_velocity(80, PERCENT)\n    Roll.set_stopping(COAST)\n    while True:\n        if sussy == 'sus':\n            L.set_velocity(controller_1.axis3.position(), PERCENT)\n            R.set_velocity(controller_1.axis2.position(), PERCENT)\n        else:\n            R.set_velocity(controller_1.axis3.position()*-1, PERCENT)\n            L.set_velocity(controller_1.axis2.position()*-1, PERCENT)\ndef onevent_controller_1buttonUp_pressed_0():\n    Roll.spin(FORWARD)\ndef onevent_controller_1buttonRight_pressed_0():\n    Roll.stop()\ndef onevent_controller_1buttonDown_pressed_0():\n    Roll.spin(REVERSE)\ndef onevent_controller_1buttonL1_pressed_0():\n\n    Flywheel.spin(FORWARD)\ndef onevent_controller_1buttonL2_pressed_0():\n    Flywheel.stop()\ndef onevent_controller_1buttonX_pressed_0():\n    global sussy\n    if sussy == 'sus':\n        sussy ='jdababy'\n    else:\n        sussy = 'sus'\ndef onevent_controller_1buttonR1_pressed_0():\n    pp.set(True)\n    wait(0.2, SECONDS)\n    pp.set(False)\n\n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    auton_task_0 = Thread( onauton_autonomous_0 )\n    # wait for the driver control period to end\n    while( competition.is_autonomous() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the autonomous control tasks\n    auton_task_0.stop()\n\ndef vexcode_driver_function():\n    # Start the driver control tasks\n    driver_control_task_0 = Thread( ondriver_drivercontrol_0 )\n\n    # wait for the driver control period to end\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the driver control tasks\n    driver_control_task_0.stop()\n\n\n# register the competition functions\ncompetition = Competition( vexcode_driver_function, vexcode_auton_function )\n# system event handlers\ncontroller_1.buttonL1.pressed(onevent_controller_1buttonL1_pressed_0)\n\n\ncontroller_1.buttonL2.pressed(onevent_controller_1buttonL2_pressed_0)\ncontroller_1.buttonDown.pressed(onevent_controller_1buttonDown_pressed_0)\ncontroller_1.buttonUp.pressed(onevent_controller_1buttonUp_pressed_0)\ncontroller_1.buttonRight.pressed(onevent_controller_1buttonRight_pressed_0)\ncontroller_1.buttonR1.pressed(onevent_controller_1buttonR1_pressed_0)\ncontroller_1.buttonX.pressed(onevent_controller_1buttonX_pressed_0)\nwait(15, MSEC)\nwhen_started1()\n","textLanguage":"python","rconfig":[],"slot":3,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}